---
interface Props {
  title?: string;
  titleHighlight?: string;
  titleEnd?: string;
  subtitle?: string;
  subtitleHighlight?: string;
}

const {
  title = "¡Descubre tu",
  titleHighlight = "versión biker",
  titleEnd = "con TVS!",
  subtitle = "Llena el formulario y prepárate para verte como",
  subtitleHighlight = "todo un rider."
} = Astro.props;
---

<!DOCTYPE html>
<html lang="es" class="h-full m-0 p-0">
  <head>
    <meta charset="UTF-8" />
      <!-- MEJORADO: Meta viewport específico para móviles -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0, viewport-fit=cover" />
    <meta name="theme-color" content="#000000" />
    <title>TVS - Descubre tu versión biker</title>
    <style>
      /* Reset básico para asegurar que no haya márgenes */
      body, html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000;
      }
    </style>
  </head>
  <body class="h-full bg-black antialiased">
    <!-- Contenedor principal - Asegura que el fondo sea negro y cubra toda la pantalla -->
    <div class="relative w-full h-full overflow-hidden bg-black">
      <!-- 1. Ajustar el recorte de la imagen de fondo - Limitada en altura -->
      <div class="absolute inset-0 w-full h-[75%] z-0">
        <img 
          src="/assets/Start_img.png" 
          alt="Biker TVS" 
          class="w-full h-full object-cover object-left-center"
          style="object-position: 10% 50%;"
        />
      </div>

      <!-- Degradado entre imagen y bandera - AUMENTADO PARA HACERLO MÁS NOTORIO -->
      <div class="absolute top-[65%] w-full h-[15%] bg-gradient-to-b from-transparent via-black/80 to-black z-5"></div>
      
      <!-- Imagen de bandera - ahora comienza desde el 75% de altura -->
      <img 
        src="/assets/bandera.png" 
        alt="bandera" 
        class="absolute bottom-0 top-[75%] w-full h-[25%] object-cover z-0" 
      />

      <!-- Degradado oscuro SUTIL en la parte inferior de la bandera -->
      <div class="absolute bottom-0 w-full h-[8%] bg-gradient-to-t from-black/40 to-transparent z-5"></div>

      <!-- 4. Logo TVS reposicionado -->
      <div class="absolute z-[20]" style="top: 27px; left: 22px;">
        <img
          src="/assets/logo_tvs.png"
          alt="TVS Logo"
          class="w-28 h-auto"
        />
      </div>

      <!-- Contenido principal -->
      <div class="relative z-[15] h-full flex flex-col">
        <!-- 5. Título y subtítulo - RESPONSIVE -->
        <div class="mt-[50vh] px-[5%] sm:px-[10%] md:px-[15%] w-full">
          <h1 class="text-white text-center">
            <span class="text-[38px] sm:text-[45px] font-medium leading-none block">{title}</span>
            <span class="text-[38px] sm:text-[45px] font-black italic leading-none block">{titleHighlight}</span>
            <span class="text-[38px] sm:text-[45px] font-medium leading-none">con </span><span class="text-[38px] sm:text-[45px] font-black">TVS!</span>
          </h1>
          
          <!-- 6. Subtítulo - DIVIDIDO EN DOS PÁRRAFOS Y CENTRADO -->
          <p class="text-[18px] sm:text-[22px] leading-snug max-w-[90%] sm:max-w-[320px] mt-4 text-white text-center mx-auto">
            {subtitle}
          </p>
          <p class="text-[18px] sm:text-[22px] leading-snug max-w-[90%] sm:max-w-[320px] mt-2 text-center mx-auto">
            <span class="text-red-600 font-bold">{subtitleHighlight}</span>
          </p>
        </div>

        <!-- Espaciador flexible -->
        <div class="flex-1"></div>

        <!-- Sección inferior -->
        <div class="relative">
          <!-- Track del swipe button - RESPONSIVE -->
          <div class="relative pb-8 pt-4 z-20 flex justify-center w-full">
            <div 
              id="swipe-container"
              class="relative flex items-center justify-between w-[90%] max-w-[320px] h-16 bg-neutral-800/70 rounded-full p-[8px]"
            >
              <!-- Casco draggable - CENTRADO VERTICALMENTE -->
              <div 
                id="helmet-draggable"
                class="absolute left-[16px] z-10 cursor-pointer touch-none select-none"
                style="transform: translateX(0);"
              >
                <img 
                  src="/assets/icons/casco.webp" 
                  alt="Casco" 
                  class="w-[70px] h-[70px] transition-all duration-300"
                />
              </div>

              <!-- Flechas reposicionadas - ALTURA IGUALADA AL CASCO -->
              <div class="absolute right-[16px] top-1/2 transform -translate-y-1/2 flex items-center">
                <span class="arrow arrow-1">›</span>
                <span class="arrow arrow-2">›</span>
                <span class="arrow arrow-3">›</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <style>
      /* Animación de flechas */
      .arrow {
        font-size: 85px; /* Aumentado para igualar altura del casco (70px) */
        line-height: 0.8;
        color: #dc2626;
        font-weight: bold;
        margin: 0 -8px;
        animation: pulse-arrow 1.5s ease-in-out infinite;
      }

      .arrow-1 { animation-delay: 0s; }
      .arrow-2 { animation-delay: 0.2s; }
      .arrow-3 { animation-delay: 0.4s; }

      @keyframes pulse-arrow {
        0%, 100% { opacity: 0.3; transform: translateX(0); }
        50% { opacity: 1; transform: translateX(4px); }
      }
      
      /* Efecto de desvanecimiento para el casco durante el swipe */
      .swipe-active {
        opacity: 0.7;
        transform: scale(0.95);
      }
    </style>

    <script>
      // Implementación del swipe mejorada
      const helmet = document.getElementById('helmet-draggable') as HTMLElement | null;
      const container = document.getElementById('swipe-container') as HTMLElement | null;

      if (helmet && container) {
        let isDragging = false;
        let initialTouchX = 0;
        let currentHelmetX = 0;
        let containerWidth = 0;
        let helmetWidth = 0;
        let containerHorizontalPadding = 0;
        let swipeCompletedFlag = false;

        function updateDimensions() {
          if (!container || !helmet) return;
          
          // Actualización más precisa de dimensiones
          containerWidth = container.getBoundingClientRect().width;
          helmetWidth = helmet.getBoundingClientRect().width;
          
          // Obtener padding del contenedor
          const computedStyle = window.getComputedStyle(container);
          containerHorizontalPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
          
          // Asegurar que el casco esté en la posición inicial si no está arrastrando
          if (!isDragging && !swipeCompletedFlag) {
            helmet.style.transform = 'translateX(0)';
            const img = helmet.querySelector('img');
            if (img) {
              img.style.opacity = '1';
            }
          }
        }

        function getPointerX(e: TouchEvent | MouseEvent): number {
          return 'touches' in e ? e.touches[0].clientX : e.clientX;
        }

        function handleStart(e: TouchEvent | MouseEvent) {
          if (swipeCompletedFlag || !helmet || !container) return;
          updateDimensions(); // Actualizar dimensiones al inicio de cada swipe
          isDragging = true;
          initialTouchX = getPointerX(e);
          const transformMatrix = window.getComputedStyle(helmet).transform;
          currentHelmetX = (transformMatrix && transformMatrix !== 'none') ? parseFloat(transformMatrix.split(',')[4]) || 0 : 0;
          helmet.style.transition = 'none';
        }

        function handleMove(e: TouchEvent | MouseEvent) {
          if (!isDragging || swipeCompletedFlag || !helmet || !container) return;

          if (e.cancelable) e.preventDefault();
          const x = getPointerX(e);
          const deltaXFromInitialTouch = x - initialTouchX;
          const maxTranslateX = containerWidth - helmetWidth - containerHorizontalPadding;
          let newX = currentHelmetX + deltaXFromInitialTouch;
          
          // Limitar movimiento dentro de los límites
          newX = Math.max(0, newX);
          newX = Math.min(newX, maxTranslateX);
          
          // Aplicar transformación
          helmet.style.transform = `translateX(${newX}px)`;
          
          // Aplicar efecto de desvanecimiento según la distancia recorrida
          const progress = newX / maxTranslateX;
          const img = helmet.querySelector('img');
          if (img) {
            img.style.opacity = (1 - progress * 0.5).toString(); // Desvanecimiento gradual
          }
          
          // Umbral menor para dispositivos más pequeños
          const swipeThreshold = window.innerWidth < 375 ? 0.65 : 0.75;
          if (newX >= maxTranslateX * swipeThreshold) {
            completeSwipe(maxTranslateX);
          }
        }

        function handleEnd() {
          if (swipeCompletedFlag || !isDragging || !helmet || !container) return;
          isDragging = false;
          const currentTransform = parseFloat(helmet.style.transform.replace('translateX(', '').replace('px)', '')) || 0;
          const maxTranslateX = containerWidth - helmetWidth - containerHorizontalPadding;

          // Umbral menor para dispositivos más pequeños
          const swipeThreshold = window.innerWidth < 375 ? 0.65 : 0.75;
          
          if (currentTransform < maxTranslateX * swipeThreshold) {
            helmet.style.transition = 'transform 0.3s ease-out';
            helmet.style.transform = 'translateX(0)';
            // Restaurar la opacidad original
            const img = helmet.querySelector('img');
            if (img) {
              img.style.opacity = '1';
            }
            setTimeout(() => {
              if (helmet && !swipeCompletedFlag) helmet.style.transition = 'none';
            }, 300);
          }
        }

        function completeSwipe(maxTranslateX: number) {
          if (swipeCompletedFlag || !helmet) return;
          swipeCompletedFlag = true;
          isDragging = false;
          helmet.style.transition = 'transform 0.3s ease-out';
          helmet.style.transform = `translateX(${maxTranslateX}px)`;
          removeEventListeners();
          setTimeout(() => {
            window.location.href = '/question/datos';
          }, 350);
        }
        
        function addEventListeners(){
          helmet?.addEventListener('touchstart', handleStart, { passive: false });
          document.addEventListener('touchmove', handleMove, { passive: false });
          document.addEventListener('touchend', handleEnd);
          document.addEventListener('touchcancel', handleEnd);
          helmet?.addEventListener('mousedown', handleStart);
          document.addEventListener('mousemove', handleMove);
          document.addEventListener('mouseup', handleEnd);
        }

        function removeEventListeners(){
          helmet?.removeEventListener('touchstart', handleStart);
          document.removeEventListener('touchmove', handleMove);
          document.removeEventListener('touchend', handleEnd);
          document.removeEventListener('touchcancel', handleEnd);
          helmet?.removeEventListener('mousedown', handleStart);
          document.removeEventListener('mousemove', handleMove);
          document.removeEventListener('mouseup', handleEnd);
        }

        addEventListeners();
        updateDimensions(); // Cargar dimensiones iniciales
        window.addEventListener('resize', () => {
            if(!swipeCompletedFlag) {
              updateDimensions();
            }
        });
      }
    </script>
  </body>
</html>